import { Command, Config, Interfaces } from "@oclif/core";
import * as types from "./types";
declare namespace MongooseTsgen {
    type CliFlagConfig = Interfaces.InferredFlags<typeof MongooseTsgen["flags"]>;
    type FlagConfig = types.Normalize<Omit<CliFlagConfig, "config" | "help" | "json" | "output" | "project"> & {
        output: string;
        project: string;
    }>;
    type ArgConfig = types.Normalize<Interfaces.InferredArgs<typeof MongooseTsgen["args"]>>;
    interface Config {
        flags: FlagConfig;
        args: ArgConfig;
    }
}
declare class MongooseTsgen extends Command {
    static id: string;
    static description: string;
    static flags: {
        config: Interfaces.OptionFlag<string | undefined, import("@oclif/core/lib/interfaces/parser").CustomOptions>;
        "dry-run": Interfaces.BooleanFlag<boolean>;
        help: Interfaces.BooleanFlag<never>;
        imports: Interfaces.OptionFlag<string[] | undefined, import("@oclif/core/lib/interfaces/parser").CustomOptions>;
        "no-format": Interfaces.BooleanFlag<boolean>;
        output: Interfaces.OptionFlag<string | undefined, import("@oclif/core/lib/interfaces/parser").CustomOptions>;
        project: Interfaces.OptionFlag<string | undefined, import("@oclif/core/lib/interfaces/parser").CustomOptions>;
        debug: Interfaces.BooleanFlag<boolean>;
        "no-mongoose": Interfaces.BooleanFlag<boolean>;
        "dates-as-strings": Interfaces.BooleanFlag<boolean>;
        "no-populate-overload": Interfaces.BooleanFlag<boolean>;
    };
    static args: {
        model_path: import("@oclif/core/lib/interfaces/parser").Arg<string | undefined, Record<string, unknown>>;
    };
    constructor(argv: string[], config?: Config);
    private getConfig;
    run(): Promise<void>;
    generateDefinitions(config: MongooseTsgen.Config): Promise<{
        genFilePath: string;
        sourceFile: import("ts-morph").SourceFile;
    }>;
}
export = MongooseTsgen;
